# Generated by Django 4.0.4 on 2022-06-06 17:53

import json
from django.db import migrations, models
from django.core.exceptions import FieldDoesNotExist
from django.db.models.fields.related import ForeignObjectRel
from django.utils import timezone
from wagtail.fields import StreamField, StreamValue
from django.conf import settings


def model_from_serializable_data(model, data, check_fks=True, strict_fks=False):
    pk_field = model._meta.pk
    kwargs = {}
    stream_fields = {}

    # If model is a child via multitable inheritance, we need to set ptr_id fields all the way up
    # to the main PK field, as Django won't populate these for us automatically.
    while pk_field.remote_field and pk_field.remote_field.parent_link:
        kwargs[pk_field.attname] = data['pk']
        pk_field = pk_field.remote_field.model._meta.pk

    kwargs[pk_field.attname] = data['pk']

    for field_name, field_value in data.items():
        try:
            field = model._meta.get_field(field_name)
        except FieldDoesNotExist:
            continue

        # Filter out reverse relations
        if isinstance(field, ForeignObjectRel):
            continue

        if field.remote_field and isinstance(field.remote_field, models.ManyToManyRel):
            related_objects = field.remote_field.model._default_manager.filter(pk__in=field_value)
            kwargs[field.attname] = list(related_objects)

        elif field.remote_field and isinstance(field.remote_field, models.ManyToOneRel):
            if field_value is None:
                kwargs[field.attname] = None
            else:
                clean_value = field.remote_field.model._meta.get_field(field.remote_field.field_name).to_python(field_value)
                kwargs[field.attname] = clean_value
                if check_fks:
                    try:
                        field.remote_field.model._default_manager.get(**{field.remote_field.field_name: clean_value})
                    except field.remote_field.model.DoesNotExist:
                        if field.remote_field.on_delete == models.DO_NOTHING:
                            pass
                        elif field.remote_field.on_delete == models.CASCADE:
                            if strict_fks:
                                return None
                            else:
                                kwargs[field.attname] = None

                        elif field.remote_field.on_delete == models.SET_NULL:
                            kwargs[field.attname] = None

                        else:
                            raise Exception("can't currently handle on_delete types other than CASCADE, SET_NULL and DO_NOTHING")
        else:
            value = field.to_python(field_value)

            # Make sure datetimes are converted to localtime
            if isinstance(field, models.DateTimeField) and settings.USE_TZ and value is not None:
                default_timezone = timezone.get_default_timezone()
                if timezone.is_aware(value):
                    value = timezone.localtime(value, default_timezone)
                else:
                    value = timezone.make_aware(value, default_timezone)

            if isinstance(field, StreamField):
                pass

            kwargs[field.name] = value

    obj = model(**kwargs)
    # TODO StreamValue is empty for some reason. Find why.
    # print([child.block_type for child in obj.content])
    # print([child.block_type for child in kwargs['content']])

    if data['pk'] is not None:
        # Set state to indicate that this object has come from the database, so that
        # ModelForm validation doesn't try to enforce a uniqueness check on the primary key
        obj._state.adding = False

    return obj

def forward(apps, schema_editor):
    BlogPage = apps.get_model("blog", "BlogPage")
    ContentType = apps.get_model("contenttypes", "ContentType")
    PageRevision = apps.get_model("wagtailcore", "PageRevision")
    contenttype_id = ContentType.objects.get(app_label="blog", model="blogpage").id
    model_field_name = "content"
    old_name = "field1"
    new_name = "block1"

    curr_field = BlogPage._meta.get_field(model_field_name)
    all_blocks = []
    for key, value in curr_field.stream_block.child_blocks.items():
        path, args, kwargs = value.deconstruct()
        if key == new_name:
            all_blocks.append((old_name, value.__class__(*args, **kwargs)))
            all_blocks.append((new_name, value.__class__(*args, **kwargs)))
        else:
            all_blocks.append((key, value.__class__(*args, **kwargs)))
    all_fields = StreamField(all_blocks)
    all_fields.contribute_to_class(BlogPage, model_field_name)

    # change the streamfield so that it has both blocks now
    schema_editor.alter_field(BlogPage, curr_field, all_fields)

    # for page in BlogPage.objects.all():
    #     stream_blocks = getattr(page, model_field_name)
    #     for index, child in enumerate(stream_blocks):
    #         if child.block_type == old_name:
    #             stream_blocks[index] = (new_name, child.value)
    #     setattr(page, model_field_name, stream_blocks)
    #     page.save()

    # TODO change so that it's possible to update only the last couple of revisions 

    for revision in PageRevision.objects.filter(page__content_type_id=contenttype_id):
        print(revision.page_id)
        revision_as_page = model_from_serializable_data(BlogPage, revision.content)
        # print(revision_as_page.__dict__)
        stream_blocks = getattr(revision_as_page, model_field_name)
        for index, child in enumerate(stream_blocks):
            print(child)
            if child.block_type == old_name:
                stream_blocks[index] = (new_name, child.value)
                print(child.block_type, ' - ', child.value)
        

    # change the streamfield back to how it was
    schema_editor.alter_field(BlogPage, all_fields, curr_field)


def backward(apps, schema_editor):
    BlogPage = apps.get_model("blog", "BlogPage")
    model_field_name = "content"
    old_name = "field1"
    new_name = "block1"

    curr_field = BlogPage._meta.get_field(model_field_name)
    all_blocks = []
    for key, value in curr_field.stream_block.child_blocks.items():
        path, args, kwargs = value.deconstruct()
        if key == new_name:
            all_blocks.append((old_name, value.__class__(*args, **kwargs)))
            all_blocks.append((new_name, value.__class__(*args, **kwargs)))
        else:
            all_blocks.append((key, value.__class__(*args, **kwargs)))
    all_fields = StreamField(all_blocks)
    all_fields.contribute_to_class(BlogPage, model_field_name)

    # change the streamfield so that it has both blocks now
    schema_editor.alter_field(BlogPage, curr_field, all_fields)

    # for page in BlogPage.objects.all():
    #     stream_blocks = getattr(page, model_field_name)
    #     for index, child in enumerate(stream_blocks):
    #         if child.block_type == new_name:
    #             stream_blocks[index] = (old_name, child.value)
    #     setattr(page, model_field_name, stream_blocks)
    #     page.save()

    # change the streamfield back to how it was
    schema_editor.alter_field(BlogPage, all_fields, curr_field)


class Migration(migrations.Migration):

    dependencies = [
        ("blog", "0003_alter_blogpage_content"),
    ]

    operations = [
        migrations.RunPython(forward, forward)
    ]
