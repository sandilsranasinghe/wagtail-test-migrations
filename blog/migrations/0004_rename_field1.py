# Generated by Django 4.0.4 on 2022-06-06 17:53

import datetime
from django.db import migrations, models
from django.core.exceptions import FieldDoesNotExist
from django.db.models.fields.related import ForeignObjectRel
from django.utils import timezone
from django.utils.encoding import is_protected_type
from wagtail.fields import StreamField, StreamValue
from django.conf import settings


# TODO drop unnecessary parts
def get_serializable_data_for_fields(model):
    """
    Return a serialised version of the model's fields which exist as local database
    columns (i.e. excluding m2m and incoming foreign key relations)
    """
    pk_field = model._meta.pk
    # If model is a child via multitable inheritance, use parent's pk
    while pk_field.remote_field and pk_field.remote_field.parent_link:
        pk_field = pk_field.remote_field.model._meta.pk

    obj = {"pk": get_field_value(pk_field, model)}

    for field in model._meta.fields:
        if field.serialize:
            obj[field.name] = get_field_value(field, model)

    return obj


def get_field_value(field, model):
    if field.remote_field is None:
        value = field.pre_save(model, add=model.pk is None)

        # Make datetimes timezone aware
        # https://github.com/django/django/blob/master/django/db/models/fields/__init__.py#L1394-L1403
        if isinstance(value, datetime.datetime) and settings.USE_TZ:
            if timezone.is_naive(value):
                default_timezone = timezone.get_default_timezone()
                value = timezone.make_aware(value, default_timezone).astimezone(
                    timezone.utc
                )
            # convert to UTC
            value = timezone.localtime(value, timezone.utc)

        if is_protected_type(value):
            return value
        else:
            return field.value_to_string(model)
    else:
        return getattr(model, field.get_attname())


def model_from_serializable_data(model, data, check_fks=True, strict_fks=False):
    pk_field = model._meta.pk
    kwargs = {}

    # If model is a child via multitable inheritance, we need to set ptr_id fields all the way up
    # to the main PK field, as Django won't populate these for us automatically.
    while pk_field.remote_field and pk_field.remote_field.parent_link:
        kwargs[pk_field.attname] = data["pk"]
        pk_field = pk_field.remote_field.model._meta.pk

    kwargs[pk_field.attname] = data["pk"]

    for field_name, field_value in data.items():
        try:
            field = model._meta.get_field(field_name)
        except FieldDoesNotExist:
            continue

        # Filter out reverse relations
        if isinstance(field, ForeignObjectRel):
            continue

        if field.remote_field and isinstance(field.remote_field, models.ManyToManyRel):
            related_objects = field.remote_field.model._default_manager.filter(
                pk__in=field_value
            )
            kwargs[field.attname] = list(related_objects)

        elif field.remote_field and isinstance(field.remote_field, models.ManyToOneRel):
            if field_value is None:
                kwargs[field.attname] = None
            else:
                clean_value = field.remote_field.model._meta.get_field(
                    field.remote_field.field_name
                ).to_python(field_value)
                kwargs[field.attname] = clean_value
                if check_fks:
                    try:
                        field.remote_field.model._default_manager.get(
                            **{field.remote_field.field_name: clean_value}
                        )
                    except field.remote_field.model.DoesNotExist:
                        if field.remote_field.on_delete == models.DO_NOTHING:
                            pass
                        elif field.remote_field.on_delete == models.CASCADE:
                            if strict_fks:
                                return None
                            else:
                                kwargs[field.attname] = None

                        elif field.remote_field.on_delete == models.SET_NULL:
                            kwargs[field.attname] = None

                        else:
                            raise Exception(
                                "can't currently handle on_delete types other than CASCADE, SET_NULL and DO_NOTHING"
                            )
        else:
            value = field.to_python(field_value)

            # Make sure datetimes are converted to localtime
            if (
                isinstance(field, models.DateTimeField)
                and settings.USE_TZ
                and value is not None
            ):
                default_timezone = timezone.get_default_timezone()
                if timezone.is_aware(value):
                    value = timezone.localtime(value, default_timezone)
                else:
                    value = timezone.make_aware(value, default_timezone)

            kwargs[field.name] = value

    obj = model(**kwargs)
    # TODO StreamValue is empty for some reason. Find why.
    # print([child.block_type for child in obj.content])
    # print([child.block_type for child in kwargs['content']])

    if data["pk"] is not None:
        # Set state to indicate that this object has come from the database, so that
        # ModelForm validation doesn't try to enforce a uniqueness check on the primary key
        obj._state.adding = False

    return obj, kwargs


def forward(apps, schema_editor):
    BlogPage = apps.get_model("blog", "BlogPage")
    ContentType = apps.get_model("contenttypes", "ContentType")
    PageRevision = apps.get_model("wagtailcore", "PageRevision")
    contenttype_id = ContentType.objects.get(app_label="blog", model="blogpage").id
    model_field_name = "content"
    old_name = "field1"
    new_name = "block1"

    curr_field = BlogPage._meta.get_field(model_field_name)
    all_blocks = []
    for key, value in curr_field.stream_block.child_blocks.items():
        path, args, kwargs = value.deconstruct()
        if key == new_name:
            all_blocks.append((old_name, value.__class__(*args, **kwargs)))
            all_blocks.append((new_name, value.__class__(*args, **kwargs)))
        else:
            all_blocks.append((key, value.__class__(*args, **kwargs)))
    all_fields = StreamField(all_blocks)
    all_fields.contribute_to_class(BlogPage, model_field_name)

    # change the streamfield so that it has both blocks now
    schema_editor.alter_field(BlogPage, curr_field, all_fields)

    for page in BlogPage.objects.all():
        stream_blocks = getattr(page, model_field_name)
        for index, child in enumerate(stream_blocks):
            if child.block_type == old_name:
                stream_blocks[index] = (new_name, child.value)
        setattr(page, model_field_name, stream_blocks)
        page.save()

    # TODO change so that it's possible to update only the last couple of revisions

    for revision in PageRevision.objects.filter(page__content_type_id=contenttype_id):
        revision_as_page, kwargs = model_from_serializable_data(
            BlogPage, revision.content
        )
        revision_as_page.content = StreamValue(
            revision_as_page.content.stream_block, kwargs["content"]
        )
        # print(revision_as_page.__dict__)
        stream_blocks = getattr(revision_as_page, model_field_name)
        for index, child in enumerate(stream_blocks):
            if child.block_type == old_name:
                stream_blocks[index] = (new_name, child.value)
        setattr(revision_as_page, model_field_name, stream_blocks)

        data = get_serializable_data_for_fields(revision_as_page)
        # print(data['content'])
        revision.content["content"] = data["content"]
        revision.save()

    # change the streamfield back to how it was
    schema_editor.alter_field(BlogPage, all_fields, curr_field)


def backward(apps, schema_editor):
    BlogPage = apps.get_model("blog", "BlogPage")
    ContentType = apps.get_model("contenttypes", "ContentType")
    PageRevision = apps.get_model("wagtailcore", "PageRevision")
    contenttype_id = ContentType.objects.get(app_label="blog", model="blogpage").id
    model_field_name = "content"
    old_name = "field1"
    new_name = "block1"

    curr_field = BlogPage._meta.get_field(model_field_name)
    all_blocks = []
    for key, value in curr_field.stream_block.child_blocks.items():
        path, args, kwargs = value.deconstruct()
        if key == new_name:
            all_blocks.append((old_name, value.__class__(*args, **kwargs)))
            all_blocks.append((new_name, value.__class__(*args, **kwargs)))
        else:
            all_blocks.append((key, value.__class__(*args, **kwargs)))
    all_fields = StreamField(all_blocks)
    all_fields.contribute_to_class(BlogPage, model_field_name)

    # change the streamfield so that it has both blocks now
    schema_editor.alter_field(BlogPage, curr_field, all_fields)

    for page in BlogPage.objects.all():
        stream_blocks = getattr(page, model_field_name)
        for index, child in enumerate(stream_blocks):
            if child.block_type == new_name:
                stream_blocks[index] = (old_name, child.value)
        setattr(page, model_field_name, stream_blocks)
        page.save()

    for revision in PageRevision.objects.filter(page__content_type_id=contenttype_id):
        revision_as_page, kwargs = model_from_serializable_data(
            BlogPage, revision.content
        )
        revision_as_page.content = StreamValue(
            revision_as_page.content.stream_block, kwargs["content"]
        )
        # print(revision_as_page.__dict__)
        stream_blocks = getattr(revision_as_page, model_field_name)
        for index, child in enumerate(stream_blocks):
            if child.block_type == new_name:
                stream_blocks[index] = (old_name, child.value)
        setattr(revision_as_page, model_field_name, stream_blocks)

        data = get_serializable_data_for_fields(revision_as_page)
        # print(data['content'])
        revision.content["content"] = data["content"]
        revision.save()

    # change the streamfield back to how it was
    schema_editor.alter_field(BlogPage, all_fields, curr_field)


class Migration(migrations.Migration):

    dependencies = [
        ("blog", "0003_alter_blogpage_content"),
    ]

    operations = [migrations.RunPython(forward, backward)]
